<?php

namespace Dime\TimetrackerBundle\Entity;

use Dime\TimetrackerBundle\Entity\Tag;
use Dime\TimetrackerBundle\Entity\User;
use Doctrine\ORM\QueryBuilder;
/**
 * TagRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TagRepository extends EntityRepository
{
    /**
     * Search
     * Not implemented yet.
     *
     * @param string            $text
     * @param QueryBuilder      $qb
     *
     * @return TagRepository
     */
    public function search($text, QueryBuilder $qb = null)
    {
        if ($qb == null) {
            $qb = $this->builder;
        }

        $aliases = $qb->getRootAliases();
        $alias = array_shift($aliases);

        $qb->andWhere(
            $qb->expr()->like($alias . '.name', ':text_like')
        );
        $qb->setParameter('text_like', '%' . $text . '%');

        return $this;
    }

    /**
     * Scope by date,
     * Not implemented yet.
     *
     * @param                   $date
     * @param QueryBuilder      $qb
     *
     * @return TagRepository
     */
    public function scopeByDate($date, QueryBuilder $qb = null)
    {
        return $this;
    }


    /**
     * get ids for tags and create non-existing ones
     *
     * @param array        $tags Array of strings
     * @param QueryBuilder $qb   Query builder instance
     * @return array (name => id)
     */
    public function getIdsForTags(array $tags, User $user, QueryBuilder $qb = null)
    {
        if ($qb == null) {
            $qb = $this->builder;
        }

        if (!empty($tags)) {
            $qb->add('select', 't.name, t.id')
               ->andWhere(
                    $qb->expr()->andX(
                        $qb->expr()->in('t.name', ':tags'),
                        $qb->expr()->eq('t.user', ':user')
                    )
                )
                ->setParameters(array('tags' =>  $tags, 'user' => $user->getId()));

            $existingTags = $qb->getQuery()->getResult();
            $ids = array();
            foreach ($existingTags as $tag) {
                $ids[$tag['name']] = $tag['id'];
            }
            $missingTags = array_diff($tags, array_keys($ids));
            if (0 < count($missingTags)) {
                foreach ($missingTags as $tagName) {
                    $newTag = new Tag();
                    $newTag->setName($tagName);
                    $newTag->setUser($user);
                    $this->getEntityManager()->persist($newTag);
                }
                $this->getEntityManager()->flush();
                $ids = array_merge($ids, $this->getIdsForTags(array_values($missingTags), $user, $qb));
            }
            return array_values($ids);
        } else {
            return array();
        }
    }
}
